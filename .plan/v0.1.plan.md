# Braintrust Go SDK v0.1 Plan

**Status:** Draft for Review
**Goal:** Clean break release with improved architecture, better state management, and extensible APIs

---

## 1. Module & Package Restructure

### Module Rename
- **Old:** `github.com/braintrustdata/braintrust-x-go`
- **New:** `github.com/braintrustdata/braintrust-sdk-go`
- **Approach:** Clean break, no backward compatibility

### Package Structure (Flat)
```
github.com/braintrustdata/braintrust-sdk-go/
├── trace/              # Core tracing (was braintrust/trace/)
├── eval/               # Evaluations (was braintrust/eval/)
├── api/                # API client (was braintrust/api/)
├── contrib/            # Third-party integrations
│   ├── openai/         # (was trace/traceopenai/)
│   ├── anthropic/      # (was trace/traceanthropic/)
│   ├── genai/          # (was trace/tracegenai/)
│   └── langchaingo/    # (was trace/tracelangchaingo/)
├── internal/           # Internal packages
├── TBD: config         # Config management (location TBD: root vs config/ vs auth/)
└── TBD: auth           # Login/auth (location TBD)
```

### Import Path Changes
```go
// Before
import "github.com/braintrustdata/braintrust-x-go/braintrust/trace"
import "github.com/braintrustdata/braintrust-x-go/braintrust/eval"
import "github.com/braintrustdata/braintrust-x-go/braintrust/trace/traceopenai"

// After
import "github.com/braintrustdata/braintrust-sdk-go/trace"
import "github.com/braintrustdata/braintrust-sdk-go/eval"
import "github.com/braintrustdata/braintrust-sdk-go/contrib/openai"
```

**Open Questions:**
- Exact location for config.go and login.go (root, config/, auth/, or core/)
- Other packages to consider: autoevals, attachment

---

## 2. Config & State Architecture

### Current Problems with Global State

**Issue 1: Config Cache Can't Be Changed** (`env.go:14-15`)
```go
var cachedConfig *Config  // Package-level global

func GetConfig(opts ...Option) Config {
    if cachedConfig != nil {
        return *cachedConfig  // Returns cached, ignores new opts!
    }
    // First call caches forever
}
```

**Problems:**
- Not ideal for remote evals
- First call caches config forever
- Can't override for different parts of app
- Can't have different configs in same process
- Test isolation impossible - tests share cached state
- No way to reset without restarting process

**Example failure:**
```go
// Test A runs first
trace.Quickstart() // caches BRAINTRUST_API_KEY from env

// Test B wants different config
os.Setenv("BRAINTRUST_API_KEY", "different-key")
trace.Quickstart() // STILL USES OLD KEY from cache!
```

**Issue 2: Testing Anti-Pattern** (`env.go:182`)
```go
if !testing.Testing() {
    cachedConfig = &config  // Only cache if not in test
}
```

**Problems:**
- Different behavior in tests vs production (bad!)
- `testing.Testing()` checks if ANY test is running (brittle)
- Can't test caching behavior itself
- Violates principle: tests should run production code paths

**Issue 3: No Isolation**
```go
// Package A
trace.Quickstart(braintrust.WithAPIKey("key1"))

// Package B (different service)
trace.Quickstart(braintrust.WithAPIKey("key2"))  // Too late! Uses key1
```

Can't support:
- Multiple projects in same app
- Different API keys for different services
- Isolated test environments

---

### **DECISION: Client-Based Architecture**

```go
// Create client with explicit config (sets up tracing automatically)
bt := braintrust.New(
    braintrust.WithAPIKey("..."),
    braintrust.WithProject("my-project"),
)
defer bt.Shutdown()

// API operations via bt.API()
api := bt.API()
exp, err := api.Experiments.Get(ctx, "exp-id")

// Eval convenience method on client
result, err := bt.Eval(ctx, eval.Opts{...})

// Advanced: Use eval package directly
result, err := eval.Run(ctx, eval.Opts{...})
```

**Why this approach:**
- Explicit config ownership
- Easy to have multiple clients with different configs
- Clear testing story (inject mock client)
- Familiar pattern (AWS SDK, many Go SDKs)
- Trace setup happens during initialization (no separate Quickstart needed)
- Balances convenience (bt.Eval shorthand) with flexibility (eval package direct usage)

**Implementation notes:**
- Use `braintrust.New()` following Go naming conventions
- Client initializes OpenTelemetry trace provider on creation
- `bt.API()` returns namespaced API client for direct operations
- `bt.Eval()` wraps `eval.Run()` with client configuration
- Keep `eval` package public for advanced usage patterns

**For v0.1:**
- Remove global config cache
- Remove `testing.Testing()` check
- Client manages trace provider lifecycle
- Keep login cache but make injectable for tests

### **CLIENT IMPLEMENTATION STATUS: ✅ COMPLETE** (as of 2025-10-28)

The client-based architecture has been fully implemented:

**Files:**
- `client.go` - Client struct with New() and NewWithOtel() constructors
- `client_test.go` - Comprehensive tests
- `options.go` - Functional options (WithAPIKey, WithProject, etc.)
- `config/config.go` - Config management (no global cache)
- `internal/auth/session.go` - Session-based auth with async login
- `trace/trace.go` - Tracing setup integrated with client

**API:**
```go
// Two constructors available:

// 1. Bring your own TracerProvider
tp := trace.NewTracerProvider()
client, err := braintrust.New(tp,
    braintrust.WithAPIKey("..."),
    braintrust.WithProject("my-project"),
)
defer client.Shutdown(context.Background())

// 2. Convenience constructor (creates and manages TracerProvider)
client, err := braintrust.NewWithOtel(
    braintrust.WithAPIKey("..."),
    braintrust.WithProject("my-project"),
)
defer client.Shutdown(context.Background())
```

**Client struct contains:**
- `config *config.Config` - immutable configuration
- `session *auth.Session` - authentication state
- `tracerProvider *trace.TracerProvider` - OpenTelemetry tracer
- `logger logger.Logger` - structured logging

**Features:**
- ✅ No global state (config, tracer, session all per-client)
- ✅ Async login by default (WithBlockingLogin option)
- ✅ Tracing automatically set up on initialization
- ✅ Multiple clients with different configs in same process
- ✅ Test isolation (each test creates own client)
- ✅ All tests passing

**Next Steps:**
- Integrate eval package with client (pass client to eval.Run)
- Refactor API package to use client resources
- Update examples to use new client pattern

---

## 3. Context Threading

### Add context.Context to All API Functions

**Files to update:**
- `api/experiment.go` - `RegisterExperiment(ctx, name, projectID, opts)`
- `api/project.go` - `RegisterProject(ctx, name)`
- `api/dataset.go` - all dataset functions
- `login.go` - `Login(ctx, opts)`

**Already correct:**
- ✅ `eval.Run(ctx, ...)` and all eval functions
- ✅ All trace operations (via OpenTelemetry)

**Benefits:**
- Standard Go practice for I/O operations
- Enables cancellation and timeouts
- Required for context-based config propagation
- Consistent API surface

---

## 4. API Package - Namespaced Client Architecture

### Design: Primitives + Helpers with Namespaces

```go
// Create API client
client := api.NewClient(ctx,
    api.WithAPIKey("..."),
    api.WithBaseURL("..."),
)

// Or use default client from env vars
client := api.DefaultClient(ctx)
```

### Experiments Namespace
```go
// Low-level primitives (direct API wrappers)
exp, err := client.Experiments.Create(ctx, api.CreateExperimentRequest{
    ProjectID: "proj-123",
    Name:      "my-experiment",
})
exp, err := client.Experiments.Get(ctx, "exp-id")
exp, err := client.Experiments.Update(ctx, "exp-id", api.UpdateExperimentRequest{...})
exps, err := client.Experiments.List(ctx, "proj-id")

// Helpful helpers (common patterns)
exp, err := client.Experiments.Register(ctx, "name", "proj-id", api.RegisterOpts{
    Tags:     []string{"tag1"},
    Metadata: map[string]any{"key": "val"},
})
id, err := client.Experiments.ResolveID(ctx, "nameOrID", "proj-id")
```

### Projects Namespace
```go
// Low-level primitives
proj, err := client.Projects.Create(ctx, api.CreateProjectRequest{Name: "my-proj"})
proj, err := client.Projects.Get(ctx, "proj-id")
proj, err := client.Projects.GetByName(ctx, "proj-name")
projs, err := client.Projects.List(ctx)

// Helpful helpers
proj, err := client.Projects.Register(ctx, "name")  // get-or-create
id, err := client.Projects.ResolveID(ctx, "nameOrID")
```

### Datasets Namespace
```go
// Low-level primitives
ds, err := client.Datasets.Create(ctx, api.CreateDatasetRequest{...})
ds, err := client.Datasets.Get(ctx, "dataset-id")
records, err := client.Datasets.Query(ctx, "dataset-id", api.QueryOpts{
    Version: "v1",
    Limit:   100,
})

// Helpful helpers
ds, err := client.Datasets.GetByName(ctx, "proj-id", "dataset-name")
ds, err := client.Datasets.Register(ctx, "proj-id", "name")
```

### Integration with Eval Package

```go
// Eval uses API client under the hood
cases := eval.LoadDataset(ctx, "dataset-name",
    eval.WithProject("my-project"),
    eval.WithVersion("v1"),
)
// ^ Internally uses api.DefaultClient() or injected client

// Advanced: inject custom client
result := eval.Run(ctx, eval.Opts{
    APIClient: myCustomClient,  // optional override
    // ...
})
```

**Design Notes:**
- Primitives are thin wrappers around HTTP API
- Helpers implement common patterns (get-or-create, resolve name→ID)
- Both coexist in same namespace
- Clear naming: `Create/Get/Update` = primitives, `Register/Resolve` = helpers

---

## 5. Eval Package - Dual API Design

**Goal:** Create a smaller, more focused, better-designed API surface for evaluations.

**Principles:**
- Reduce redundancy (Project/ProjectID duplication)
- Separate concerns (experiment config vs execution options vs data loading)
- Make common cases easy, complex cases possible
- Extensible for future features without breaking changes

### Recommended Pattern: Client Convenience Method + Direct Package Access

```go
// Pattern 1: Client convenience method (recommended for most users)
bt := braintrust.New(braintrust.WithProject("my-project"))
result, err := bt.Eval(ctx, eval.Opts[string, string]{
    Experiment:  "my-experiment",
    Dataset:     "dataset-name",
    Task:        myTask,
    Scorers:     myScorers,
    Parallelism: 4,
    Tags:        []string{"v1"},
    Metadata:    map[string]any{"model": "gpt-4"},
})

// Pattern 2: Direct package usage (for advanced cases)
result, err := eval.Run(ctx, eval.Opts[string, string]{
    Project:     "my-project",
    Experiment:  "my-experiment",
    Dataset:     "dataset-name",
    Task:        myTask,
    Scorers:     myScorers,
    Parallelism: 4,
    Tags:        []string{"v1"},
    Metadata:    map[string]any{"model": "gpt-4"},
})
```

**How bt.Eval() works:**
- Wraps `eval.Run()` internally
- Inherits client configuration (project, API key, etc.)
- User can override inherited values in Opts
- Provides cleaner API when client already has project/credentials

### Opts Struct Improvements

**Current issues:**
- 15+ fields mixing different concerns
- Redundant fields: `Project`/`ProjectID`, `Dataset`/`DatasetID`

**Proposed changes for v0.1:**
- Keep separate name/ID fields (explicit is better)
- Keep flat `Opts` struct (no grouping for now)
- Add extension points for future features (hooks, trials, etc.)
- Client configuration can provide defaults (project, API key)

**No need for object-oriented eval.New() pattern:**
- `bt.Eval()` provides convenience for common case
- `eval.Run()` provides flexibility for direct usage
- Simple, clear API surface

---

## 6. Eval Feature Parity - Future Extension Points

### Python/TypeScript Features Not Yet Supported

Based on SDK research, these features need support:

#### A. EvalHooks (High Priority)
**Purpose:** Runtime access to evaluation metadata in task functions

*Suggested APIs (design in future session):*
```go
// Future: Task signature will accept hooks
type Task[I, R any] func(ctx context.Context, input I, hooks EvalHooks) (R, error)

// EvalHooks interface (v0.1: define but don't use yet)
type EvalHooks interface {
    Metadata() Metadata              // Get/mutate case metadata
    SetMetadata(key string, val any)
    Tags() []string                  // Get/mutate tags
    AddTag(tag string)
    Expected() R                     // Access expected value
    TrialIndex() int                 // Current trial (when TrialCount > 1)
    Span() trace.Span                // Access underlying span
}
```

#### B. Trial Support (High Priority)
**Purpose:** Run each case multiple times for non-deterministic tasks

*Suggested APIs (design in future session):*
```go
type Opts struct {
    // ...existing fields...
    TrialCount int  // Run each case N times, Braintrust aggregates scores
}
```

#### C. Error Score Handler (High Priority)
**Purpose:** Custom scoring behavior when task/scorer fails

*Suggested APIs (design in future session):*
```go
type ErrorScoreFunc func(error) Scores

type Opts struct {
    // ...existing fields...
    ErrorScoreHandler ErrorScoreFunc  // Custom error handling
}
```

#### D. BaseExperiment (Medium Priority)
**Purpose:** Compare against previous experiment outputs as baseline

*Suggested APIs (design in future session):*
```go
type Opts struct {
    // ...existing fields...
    BaseExperiment string  // Experiment name/ID to use as baseline
}
// Auto-selects best baseline using git history or timestamps
```

#### E. Additional Options (Medium Priority)

*Suggested APIs (design in future session):*
```go
type Opts struct {
    // ...existing fields...
    Timeout        time.Duration  // Max evaluation duration
    NoSendLogs     bool          // Local evaluation only, don't send to Braintrust
    MaxConcurrency int           // Fine-grained concurrency control
}
```

### v0.1 Implementation Strategy

**What we'll do:**
1. Define extension point interfaces (`EvalHooks`, `ErrorScoreFunc`)
2. Add reserved fields to `Opts` (`TrialCount`, `BaseExperiment`, etc.)
3. Document fields as "reserved for future use"
4. Ensure APIs can support these features without breaking changes
5. **Don't implement the logic yet** - just the extension points

**Example:**
```go
// v0.1: Add to Opts, document but don't implement
type Opts[I, R any] struct {
    // ...existing fields...

    // Reserved for future features (documented, not yet implemented)
    TrialCount        int             // Reserved: will support N trials per case
    ErrorScoreHandler ErrorScoreFunc  // Reserved: custom error scoring
    BaseExperiment    string          // Reserved: baseline comparison
    Timeout           time.Duration   // Reserved: eval timeout
    NoSendLogs        bool            // Reserved: local-only mode
}

// v0.1: Define interface for documentation
type EvalHooks interface {
    // Future: will be passed to Task function
    // Allows runtime mutation of metadata, tags, etc.
    Metadata() Metadata
    SetMetadata(key string, val any)
    Tags() []string
    AddTag(tag string)
    Expected() R
    TrialIndex() int
    Span() trace.Span
}
```

---

## 7. API Cleanup - Remove Redundancy

### Functions to Remove

**In `api/` package:**
- ❌ `GetOrCreateExperiment()` - redundant with `RegisterExperiment()`

**In `eval/` package:**
- ❌ `ResolveProjectExperimentID()` - redundant with `ResolveExperimentID()`
- ❌ `ResolveKey()` - make internal/private (not needed publicly)

### Keep Separate Name vs ID Fields

**Decision:** Keep explicit separation between name and ID fields

```go
// In Opts - user picks one or the other
type Opts struct {
    Project   string  // by name
    ProjectID string  // by ID (mutually exclusive with Project)

    Dataset   string  // by name
    DatasetID string  // by ID (mutually exclusive with Dataset)
}
```

**In API functions:**
```go
// Separate ByName and ByID methods
client.Projects.Get(ctx, id)           // by ID
client.Projects.GetByName(ctx, name)   // by name
client.Projects.Register(ctx, name)    // get-or-create by name

client.Datasets.Get(ctx, id)           // by ID
client.Datasets.GetByName(ctx, projectID, name)  // by name
```

**Benefits:**
- Explicit and clear
- No magic auto-detection
- Easier to document and understand

### Other Cleanup

- Remove `testing.Testing()` check in `env.go:182`
- Remove global `cachedConfig` (replaced by new architecture)
- Make `globalLoginCache` injectable for tests

---

## 8. Migration Guide

**TODO:** Write comprehensive migration guide before v0.1 release

The guide should cover:
- Module path changes (braintrust-x-go → braintrust-sdk-go)
- Package import path changes (flat structure, contrib/ location)
- API signature changes (context parameters)
- Breaking vs non-breaking changes
- Example code updates
- Common migration issues and solutions

---

## 9. Areas Requiring Detailed Design

These topics need deeper design sessions after v0.1 plan approval:

### A. ~~Config Architecture Decision~~ ✅ DECIDED
- **Decision:** Client-based architecture with `braintrust.New()`
- Client owns configuration and trace provider
- See Section 2 for full details

### B. API Client Implementation
- Request/response types for all endpoints
- Error handling patterns
- Retry logic
- Rate limiting

### C. ~~Eval Object-Oriented API~~ ✅ DECIDED
- **Decision:** Use simple dual API pattern
- `bt.Eval()` for convenience, `eval.Run()` for direct usage
- No need for object-oriented eval.New() pattern
- See Section 5 for full details

### D. EvalHooks Implementation
- How hooks are created and passed to tasks
- Span access patterns
- Metadata mutation during execution
- Thread-safety considerations

### E. Trial Execution
- Aggregation logic for multiple trials
- Bucketing strategy by input
- Score variance calculation
- Performance implications

### F. Error Handling
- Default error score handler behavior
- Custom handler patterns
- Partial failure modes
- Error reporting

### G. Package Organization
- Final location for config, auth, login
- Autoevals package location and integration
- Attachment package location
- Internal vs public boundaries

---

## 10. Next Steps

1. Review and approve this plan
2. Schedule detailed design sessions for areas marked "design in future session"
3. Begin implementation
4. Release v0.1.0
